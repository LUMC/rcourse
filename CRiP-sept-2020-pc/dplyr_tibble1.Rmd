---
title: 'tibble vs data.frame'
# author: "R. Monajemi"
params:
  basename: "dplyr_tibble1"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = NA, paged.print=FALSE)
build_nocode(params) # build nocode version of tasks ; 
                     # replace with source("setup.R") when running stand-alone (knit)
```

```{r, child="_navigate.Rmd"} 
``` 

A tibble is the upgraded version of [data.frame]() data type with some convenient additional features, moreover, it is the standard data structure in tidyverse. In the following I'll layout the main features and differences in comparison with data.frame. Let's create a data.frame and a tibble manually with the same content.

## Create

Take for example the variables `name`, `year` and `favourite` to represent a person's name, birth year and favourite colour    

__data.frame__
```{r, echo=TRUE }
t1 <- data.frame(name=c("Lucas","Lotte","Noa"), 
                 year=1995, 
                 favourite=c("Blue","Green","Yellow"))
t1
```
        
__tibble__
```{r, echo=TRUE}
# tibble
t2  <- tibble(name=c("Lucas","Lotte","Noa"), 
             year=1995, 
             favourite=c("Blue","Green","Yellow"))
t2
```

> What is the difference between tibble and data.frame output?

```{.fold}
The tibble output has two additional pieces of information i) the dimension of 
the data frame and ii) the column types between angle brackets (<...>).
```

Let's now inspect the types of the tibble and data.frame objects:   

```{r}
class(t1) # data.frame
class(t2) # tibble
```

Clearly they are both data frames, however tibble has additional types associated with it, i.e. `tbl` and `tbl_df`. This is how you can recognize tibble objects. 


## strings as factors

> What are the base types of the data.frame `t1` columns?

```{.fold}
'name' and 'favorite' are factors and year is of type double.
```

`data.frame` function by default converts all character variables into [factor]():

```{r}
class(t1$name)
class(t1$favorite)
```

In general, not all character variables are categorical, for example it makes less sense to have the variable 
`name` as a factor, whereas `favourite` is a good candidate. `tibble` does not make any assumptions on the type of the variable treats all character variables as base type character `chr`.

## column selection 

Columns selection with tibble always results into a tibble, this is not the case with data.frame. 

```{r}
# data.frame
t1[3]  
t1[,3]
# tibble
t2[3]  
t2[,3]
```

Selecting a single column with data.frame using comma results in a vector, and not a data frame as is the case when selecting from a tibble.




## row names 

data.frame type allow row names and they are often used as a kind of variable, however they are dropped when using tibbles and their usage is discouraged.

> Can you think of an argument against using rownames?

```{.fold}
The argument against row names is that they are not formally part of the data and therefore 
can not be maintained consistently throughout analysis pipelines. 
```

Let's look at the current row names of t1 and t2:

```{r}
rownames(t1)
rownames(t2)
```

The function `rownames` returns a character vector of 1 to the number of rows in the data frame. It can also be used to assign row names:

 
```{r}
t <- t1 # t is a copy of data.frame t1
rownames(t) <- letters[1:nrow(t1)]
t
rownames(t)
```

Let's try to assign row names to a tibble:

```{r}
rownames(t2) <- letters[1:nrow(t2)]
```

It results into a warning and the tibble is unchanged:

```{r}
t2
```


> t is a data.frame with row names a,b and c. What is the result of `rownames(as_tibble(t1))`? 

```{.fold}
[1] "1" "2" "3"
```



## partial column name matching

data.frame allows partial column name matching. for example in t1 data.frame all sequences f, fa, fav, ... will match to the column favourite:

```{r}
t1$f    # t1 is a data.frame
t1$fa
t1$fav
```

With tibble this will result into a NULL and a warning:

```{r}
t2$fa   # t2 is a tibble
```

> Can you think of an argument why this choice of partial matching is dropped in tibble?

```{.fold}
Having a partial call such as t1$fa assumes that t1 will never be updated with a new 
column called fa. Because when that happens then your r script with call t1$fa will no 
longer result into t1$favourite bu the a more exact match t1$fa.   
```


```{r, echo=FALSE}
# ## Other features
# - column name repair: column names are not changed, for example in case of duplicate names
# - layout of data frames with large number of columns 
```


```{r, echo=FALSE}
## CAREMA data set (?)
```

```{r, child="_exercises_links.Rmd"}
``` 

```{r, child="_navigate.Rmd"} 
``` 