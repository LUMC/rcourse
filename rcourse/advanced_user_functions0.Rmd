---
title: 'User-defined functions'
params:
  basename: "advanced_user_functions0"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment = NA, paged.print=FALSE)
build_nocode(params)  # UNCOMMENT IF SLOT HAS TASKS.
pulse <- read_pulse()

```

```{r, child="_navigate.Rmd"} 
``` 

## Motivation

Here is a scenario of a data analysis based on the pulse dataset. We will develop our analysis step by step :  

> Calculate mean height for individuals in range 50 to 60 kg.


```{r, collapse=TRUE}
pulse %>% filter(weight >= 50 & weight <= 60) %>% summarise(meanHeight=mean(height))
```

> For the same individuals, for how many of them did the pulse increase?

```{r, collapse=TRUE}
pulse %>% filter(weight >= 50 & weight <= 60) %>% 
    summarise(meanHeight=mean(height))
pulse %>% filter(weight >= 50 & weight <= 60) %>% 
    summarise(increasedPulse=sum(pulse1<pulse2))
```

> Refactor (removing repeatitions) and make sure `increasedPulse` does not produce NA's.

```{r, collapse=TRUE}
pulse %>% filter(weight >= 50 & weight <= 60) %>% 
  summarise(meanHeight=mean(height),
            increasedPulse=sum(pulse1<pulse2, na.rm = TRUE))
```

> Repeat this for other weight ranges 60-70 and 70-80.

Here you'll need to decide on the intervals end points. For example whether you want to include 60 in the interval above when you consider a second interval from 60 to 70. Should 60 be taken in 50-60 or in 60-70? Here we choose the include the lower bound of the interval and exclude the upper bound, i.e `weight >= 50 & weight < 60`. 


```{r collapse=TRUE}
pulse %>% filter(weight >= 50 & weight < 60) %>% 
  summarise(meanHeight=mean(height),
            increasedPulse=sum(pulse1<pulse2, na.rm = TRUE))

pulse %>% filter(weight >= 60 & weight < 70) %>% 
  summarise(meanHeight=mean(height),
            increasedPulse=sum(pulse1<pulse2, na.rm = TRUE))

pulse %>% filter(weight >= 70 & weight < 80) %>% 
  summarise(meanHeight=mean(height),
            increasedPulse=sum(pulse1<pulse2, na.rm = TRUE))
```

> Summarise the number of individuals in all groups.

```{r, collapse=TRUE}
pulse %>% filter(weight >= 50 & weight < 60) %>% 
  summarise(meanHeight=mean(height),
            increasedPulse=sum(pulse1<pulse2, na.rm = TRUE), individuals=n())
pulse %>% filter(weight >= 60 & weight < 70) %>% 
  summarise(meanHeight=mean(height),
            increasedPulse=sum(pulse1<pulse2, na.rm = TRUE), individuals=n())
pulse %>% filter(weight >= 70 & weight < 80) %>% 
  summarise(meanHeight=mean(height),
            increasedPulse=sum(pulse1<pulse2, na.rm = TRUE), individuals=n())
```


> Define the function `weightRangeSummary` which takes pulse dataset along with the interval and produces the summary as shown below: 

```{r, echo=FALSE}
weightRangeSummary <- function(x, lowerBound,upperBound) {
  x %>% filter(weight >= lowerBound & weight < upperBound) %>% 
    summarise(meanHeight=mean(height),
              increasedPulse=sum(pulse1<pulse2, na.rm = TRUE), individuals=n())
}

```

```{r,collapse=TRUE}
weightRangeSummary(pulse,50,60)
```


## Simple function

**Functions** are constructs that encapsulate series of **statements** so you do not repeat the same statements all over again when needed. 

```{r, eval=FALSE}
functionName <- function(...) {
  statement
  ...
  <value>  # the result of the function, alternatively: return(<value>)
} 
```

### First example

We **define** the following function `add_one`. It takes the value of an **argument** `x` and adds number `1` to it. The sum is the **result** of the function:

```{r}
add_one <- function(x) {
	x + 1
}
```

This function can now be **called** with different values of the argument `x`:

```{r}
add_one(2)
add_one(-1)
```

Type the function name without any `()` to see the **body** (definition) of the function?

```{r}
add_one
```

What is the class of `add_one`? 

```{r}
class( add_one )
```

### Second example

Now let's define a function to calculate $x^2 + 1$:

```{r}
square_add_one <- function(x) {
	result <- x^2    # choose a variable for temporary result
	result + 1
}

square_add_one(2) # 2^2 + 1 = 5
square_add_one(-1) # (-1)^2 + 1 = 2

```

The following versions of this functions are all equivalent:

```{r, eval=FALSE}
# (v1) One operation per line.
square_add_one <- function(x) {
	result <- x^2
	result <- result + 1
	result    # The last statement is returned as the value.
}
# (v2) No additional 'result' variable needed 
square_add_one <- function(x) {
	x^2 + 1
}
```

### Multiple arguments example

Functions may take as many arguments as needed. 
Recall the function `add_one` defined above: now we would like to have a more `generic` function which allows different values to be added (not only `1`):

```{r}
addValue <- function(x,i) {
  # add i to x
  x + i
}

addValue(2,1)             # <=> add_one(2)
addValue(11,2)            # add 2 to 11
```

You may use the argument names explicitly:  

```{r}
addValue( x = 14, i = 7 ) # add 7 to 14
```

### Logical result example

Now let's write a function `odd` which would take as an argument a whole number and return a logical `TRUE` if the number is an odd number and FALSE otherwise.

A whole number is odd when it is not integer divisible by 2. 
We can check this by taking it's remainder of integer division (`%%` operator) by 2 and see whether it is non-zero:

```{r}
odd <- function(x) {
  x %% 2 != 0
}

odd(31) 
odd( x = 6 ) # more readable than '6 %% 2 != 0' 
```

*Quiz:* what if `x` is  i) not a whole number, ii) a vector or iii) a character value?

## Some observations

  - User-defined functions lead to a more structured and easier to read code.
  - Variables declared inside a function cease to exist once the function terminates.
  - Arguments are given in the same order as they are declared in the function unless the argument names are provided explicitly.


```{r, child="_exercises_links.Rmd"}
``` 

```{r, child="_navigate.Rmd"} 
``` 
